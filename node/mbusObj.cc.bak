#include <uv.h>
#include "mbusObj.h"
#include "message.h"
#include "io_message.h"
#include "util.h"
using v8::Context;
using v8::Function;
using v8::FunctionCallbackInfo;
using v8::FunctionTemplate;
using v8::Isolate;
using v8::Local;
using v8::Number;
using v8::Object;
using v8::Persistent;
using v8::String;
using v8::Value;
using v8::Handle;
using v8::HandleScope;
using v8::CopyablePersistentTraits;
using namespace boost::interprocess;
namespace mbus {

static Persistent<Function, CopyablePersistentTraits<Function>> cb_;

struct reqData
{
    std::string result;
};


Persistent<Function> mbusObj::constructor;

mbusObj::mbusObj():ip_(0),index_(0){
   uv_async_init(uv_default_loop(), &async, mbusObj::asyncCallback);
}

mbusObj::~mbusObj() {
}

void mbusObj::Init(Local<Object> exports) {
  Isolate* isolate = exports->GetIsolate();

  Local<FunctionTemplate> tpl = FunctionTemplate::New(isolate, New);
  tpl->SetClassName(String::NewFromUtf8(isolate, "mbusObj"));
  tpl->InstanceTemplate()->SetInternalFieldCount(2);

  // Prototype
  NODE_SET_PROTOTYPE_METHOD(tpl, "write", Write);
  NODE_SET_PROTOTYPE_METHOD(tpl, "start", Start); 

  constructor.Reset(isolate, tpl->GetFunction());
  exports->Set(String::NewFromUtf8(isolate, "mbusObj"),
               tpl->GetFunction());
}

void mbusObj::New(const FunctionCallbackInfo<Value>& args) {
  Isolate* isolate = args.GetIsolate();

  if (args.IsConstructCall()) {
    mbusObj* obj = new mbusObj();
    obj->Wrap(args.This());
    args.GetReturnValue().Set(Number::New(isolate, 1));
  } else {
    // Invoked as plain function `MyObject(...)`, turn into construct call.
    const int argc = 1;
    Local<Value> argv[argc] = { args[0] };
    Local<Context> context = isolate->GetCurrentContext();
    Local<Function> cons = Local<Function>::New(isolate, constructor);
    Local<Object> result =
        cons->NewInstance(context, argc, argv).ToLocalChecked();
    args.GetReturnValue().Set(result);
  }
}

void mbusObj::Start(const FunctionCallbackInfo<Value>& args) {
    Isolate* isolate = args.GetIsolate();
    mbusObj* obj = ObjectWrap::Unwrap<mbusObj>(args.Holder());

    v8::String::Utf8Value ip_v8(args[0]->ToString());
    std::string ip = std::string(*ip_v8);
    obj->ip_ = ip2long(ip);

    obj->index_ = args[1]->NumberValue();;

    Handle<Function> arg2 = Handle<Function>::Cast(args[2]);
    Persistent<Function> cb(isolate, arg2);
    cb_ = cb;

    obj->write_mq_ = new message_queue(open_only, "mbus_receive_message_queue");

    std::string read_mq_name = "process_message_queue_"+std::to_string(obj->index_);
    std::cout << read_mq_name << std::endl;
    message_queue::remove(read_mq_name.c_str());
    obj->read_mq_(open_or_create, read_mq_name.c_str(), 10, 65535);
    

    /**
    uv_thread_t read_thread_id;
    uv_thread_create(&read_thread_id, mbusObj::consume_read_queue_thread, &(obj->index_));    
    **/

    args.GetReturnValue().Set(Number::New(isolate, 1));
}

void mbusObj::onWork(uv_work_t* req) {
     
}

void mbusObj::Write(const FunctionCallbackInfo<Value>& args) {
  Isolate* isolate = args.GetIsolate();
  v8::String::Utf8Value des_ip_v8(args[0]->ToString());
  std::string des_ip = std::string(*des_ip_v8);
  v8::String::Utf8Value param(args[3]->ToString());

  mbusObj* obj = ObjectWrap::Unwrap<mbusObj>(args.Holder());

  message msg;
  msg.type = io_message::REQUEST;
  msg.des_ip = ip2long(des_ip);
  msg.des_index = args[1]->NumberValue();
  msg.src_ip = obj->ip_;
  msg.src_index = obj->index_;
  msg.request_id = args[2]->NumberValue();
  msg.data = std::string(*param);
  std::string m;
  msg.encode_string(m); 
  std::cout << "write size " << m.size() << std::endl;

  obj->write_mq_->send(m.data(), m.size(), 0);
  args.GetReturnValue().Set(Number::New(isolate, 1));
}

void mbusObj::asyncCallback(uv_async_t *handle) {
    Isolate* isolate = Isolate::GetCurrent();
    if(isolate != NULL){
      HandleScope scope(isolate);
    }
    struct payload* p = (struct payload*)handle->data;
    std::cout << "callback str " << p->data << std::endl;
    std::cout << "str len " << strlen(p->data) << std::endl;
    /**
    int src_ip = io_message::get_src_ip_from_raw(msg_str);
    std::cout << "b 1" << std::endl;
    std::string ip = "";
    int2ip(src_ip, ip);
    std::cout << "b 2" << std::endl;

    int src_index = io_message::get_src_index_from_raw(msg_str);
    std::cout << "b 3" << std::endl;
    int request_id = io_message::get_request_id_from_raw(msg_str);
    std::cout << "b 4" << std::endl;
    std::string data;
    io_message::get_data_from_raw(msg_str, data);
    std::cout << "b 5" << std::endl;

    auto context = isolate->GetCurrentContext();
    auto global = context->Global();

    const unsigned argc = 4;
    Local<Value> argv[argc] = {Number::New(isolate, request_id),String::NewFromUtf8(isolate, ip.data()), Number::New(isolate, src_index), String::NewFromUtf8(isolate, data.data()) };
    auto fn = Local<Function>::New(isolate, cb_);
    fn->Call(global, argc, argv);
    **/
    delete p;
}

void  sendStr(std::string &str) {
      std::cout << "str " << str << std::endl;
      payload* p = new payload();
      p->data = "123";
      std::cout << "str " << str << std::endl;
      async.data = (void *)p;
      uv_async_send(&async);	
}

void mbusObj::consume_read_queue_thread(void *arg) {
    int index = *((int *) arg);
    std::string read_mq_name = "process_message_queue_"+std::to_string(index);
    std::cout << read_mq_name << std::endl;
    message_queue::remove(read_mq_name.c_str());
    message_queue read_mq_(open_or_create, read_mq_name.c_str(), 10, 65535);
   
    unsigned int priority;
    message_queue::size_type recvd_size;
   while(true){
     try{
      std::string msg_str;
      msg_str.resize(65535);
      read_mq_.receive(&msg_str[0], 65535, recvd_size, priority);
      msg_str.resize((int)recvd_size);
      sendStr(msg_str);  
     }catch(interprocess_exception &ex){
     	std::cout << ex.what() << std::endl;
     }
   }
}

}  // namespace demo
